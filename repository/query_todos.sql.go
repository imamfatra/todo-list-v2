// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: query_todos.sql

package repository

import (
	"context"
)

const addaNewTodo = `-- name: AddaNewTodo :one
INSERT INTO todos (
    todo,
    complated,
    userid
) VALUES (
    $1, $2, $3
) RETURNING id, todo, complated, userid, isdelete, deletedon
`

type AddaNewTodoParams struct {
	Todo      string `json:"todo"`
	Complated bool   `json:"complated"`
	Userid    int32  `json:"userid"`
}

func (q *Queries) AddaNewTodo(ctx context.Context, arg AddaNewTodoParams) (Todo, error) {
	row := q.db.QueryRowContext(ctx, addaNewTodo, arg.Todo, arg.Complated, arg.Userid)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Todo,
		&i.Complated,
		&i.Userid,
		&i.Isdelete,
		&i.Deletedon,
	)
	return i, err
}

const countAllTodos = `-- name: CountAllTodos :one
SELECT COUNT(*) 
FROM todos 
WHERE userid = $1 AND isdelete = FALSE
`

func (q *Queries) CountAllTodos(ctx context.Context, userid int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllTodos, userid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteaTodo = `-- name: DeleteaTodo :one
UPDATE todos
SET 
    id = $1,
    isdelete = TRUE
WHERE userid = $2
RETURNING id, todo, complated, userid, isdelete, deletedon
`

type DeleteaTodoParams struct {
	ID     int32 `json:"id"`
	Userid int32 `json:"userid"`
}

func (q *Queries) DeleteaTodo(ctx context.Context, arg DeleteaTodoParams) (Todo, error) {
	row := q.db.QueryRowContext(ctx, deleteaTodo, arg.ID, arg.Userid)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Todo,
		&i.Complated,
		&i.Userid,
		&i.Isdelete,
		&i.Deletedon,
	)
	return i, err
}

const getAllTodos = `-- name: GetAllTodos :many
SELECT id, todo, complated, userid, isdelete, deletedon 
FROM todos
WHERE userid = $1 AND isdelete = FALSE
ORDER BY id
`

func (q *Queries) GetAllTodos(ctx context.Context, userid int32) ([]Todo, error) {
	rows, err := q.db.QueryContext(ctx, getAllTodos, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.Todo,
			&i.Complated,
			&i.Userid,
			&i.Isdelete,
			&i.Deletedon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomaTodo = `-- name: GetRandomaTodo :one
SELECT id, todo, complated, userid, isdelete, deletedon 
FROM todos
WHERE isdelete = FALSE
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomaTodo(ctx context.Context) (Todo, error) {
	row := q.db.QueryRowContext(ctx, getRandomaTodo)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Todo,
		&i.Complated,
		&i.Userid,
		&i.Isdelete,
		&i.Deletedon,
	)
	return i, err
}

const getSingleaTodos = `-- name: GetSingleaTodos :one
SELECT id, todo, complated, userid, isdelete, deletedon
FROM todos
WHERE userid = $1 AND id = $2 AND isdelete = FALSE
`

type GetSingleaTodosParams struct {
	Userid int32 `json:"userid"`
	ID     int32 `json:"id"`
}

func (q *Queries) GetSingleaTodos(ctx context.Context, arg GetSingleaTodosParams) (Todo, error) {
	row := q.db.QueryRowContext(ctx, getSingleaTodos, arg.Userid, arg.ID)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Todo,
		&i.Complated,
		&i.Userid,
		&i.Isdelete,
		&i.Deletedon,
	)
	return i, err
}

const getSomeTodos = `-- name: GetSomeTodos :many
SELECT id, todo, complated, userid, isdelete, deletedon
FROM todos
WHERE userid = $1 AND isdelete = FALSE
ORDER BY id
LIMIT $2
OFFSET $3
`

type GetSomeTodosParams struct {
	Userid int32 `json:"userid"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetSomeTodos(ctx context.Context, arg GetSomeTodosParams) ([]Todo, error) {
	rows, err := q.db.QueryContext(ctx, getSomeTodos, arg.Userid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Todo
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.ID,
			&i.Todo,
			&i.Complated,
			&i.Userid,
			&i.Isdelete,
			&i.Deletedon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStatusComplate = `-- name: UpdateStatusComplate :one
UPDATE todos
SET 
    id = $1,
    complated = $2
WHERE userid = $3 AND isdelete = FALSE
RETURNING id, todo, complated, userid, isdelete, deletedon
`

type UpdateStatusComplateParams struct {
	ID        int32 `json:"id"`
	Complated bool  `json:"complated"`
	Userid    int32 `json:"userid"`
}

func (q *Queries) UpdateStatusComplate(ctx context.Context, arg UpdateStatusComplateParams) (Todo, error) {
	row := q.db.QueryRowContext(ctx, updateStatusComplate, arg.ID, arg.Complated, arg.Userid)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Todo,
		&i.Complated,
		&i.Userid,
		&i.Isdelete,
		&i.Deletedon,
	)
	return i, err
}
